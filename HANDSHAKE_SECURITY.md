# Handshake and Security Implementation Documentation

This document details the custom cryptographic handshake and security protocol implemented in the backend. The system is designed to secure communication between the client (app) and the server, protecting against tampering, replay attacks, and unauthorized access, specifically for the initial connection and sensitive data exchange.

## Overview

The security system is built on a **two-phase handshake protocol**:

1.  **Phase 1 (Initial Handshake):** The client authenticates using a hardcoded static configuration and establishes a secure, ephemeral session with the server. The server issues dynamic session keys.
2.  **Phase 2 (Secure Session):** Subsequent requests use the dynamic keys negotiated in Phase 1. This phase uses a multi-layered encryption scheme involving both static and dynamic keys.

## Core Components

### 1. Static Keys (Environment Variables)
These keys are shared between the client and server and are used for the initial handshake and as part of the layering in the second phase.

| Variable Name | Description | Length |
| :--- | :--- | :--- |
| `HANDSHAKE_AES1_KEY_B64` | Base64 encoded AES-256 key (Static). | 32 bytes |
| `HANDSHAKE_XOR1_KEY_B64` | Base64 encoded XOR key (Static). | 32 bytes |
| `HANDSHAKE_XOR2_KEY_B64` | Base64 encoded XOR key (Static). | 32 bytes |
| `HANDSHAKE_APP_AUTH_TOKEN` | A static token expected in the `x-app-auth` header for the first request. | arbitrary |

### 2. Dynamic Session Keys
Generated by the server during Phase 1 for each device session.

| Key | Description | Length |
| :--- | :--- | :--- |
| `aes2Key` | AES-256 key for CBC mode. | 32 bytes |
| `aes2Iv` | IV for AES-256 CBC mode. | 16 bytes |
| `xor3Key` | XOR key for the session. | 32 bytes |
| `apiAuthToken` | A UUID serving as the session identifier. | UUID |

---

## Phase 1: Initial Handshake

**Endpoint:** `POST /handshake`
**Goal:** Exchange device identity for dynamic session keys.

### 1. Request Structure

-   **Header:** `x-app-auth`: Must match `HANDSHAKE_APP_AUTH_TOKEN`.
-   **Body:** JSON object `{ "payload": "..." }`
-   **Payload Content:** Encrypted JSON object containing:
    ```json
    {
      "deviceId": "unique-device-id",
      "timestamp": 1234567890 (Current server time in ms)
    }
    ```

### 2. Encryption Algorithm (Layer 1)

Used for the Phase 1 request/response and the Phase 2 `x-auth` header.

**Encryption Steps (`encryptFirst`):**
1.  **Serialize:** JSON stringify the object.
2.  **UTF-8 Encode:** Convert to buffer.
3.  **XOR Layer 2:** Apply XOR with `HANDSHAKE_XOR2_KEY_B64`.
4.  **XOR Layer 1:** Apply XOR with `HANDSHAKE_XOR1_KEY_B64`.
5.  **AES Encrypt:** Encrypt using **AES-256-ECB** with `HANDSHAKE_AES1_KEY_B64`.
6.  **Encode:** Return as Base64.

**Decryption Steps (`decryptFirst`):**
1.  **Decode:** Base64 decode to buffer.
2.  **AES Decrypt:** Decrypt using **AES-256-ECB** with `HANDSHAKE_AES1_KEY_B64`.
3.  **XOR Layer 1:** Apply XOR with `HANDSHAKE_XOR1_KEY_B64`.
4.  **XOR Layer 2:** Apply XOR with `HANDSHAKE_XOR2_KEY_B64`.
5.  **Parse:** Convert to string and JSON parse.

### 3. Response Structure

The server validates the timestamp (must be within 5 seconds) and returns a JSON object `{ "ok": true, "data": "...", "timestamp": ... }`.

The `data` field is encrypted using **Layer 1** encryption.
**Decrypted Data Structure (Obfuscated):**
The actual keys are hidden inside an array (`values`) mixed with fake random data.

```json
{
  "values": [
    "fake",
    "REAL_AES2_IV_B64",      // Index 1
    "fake",
    "fake",
    "REAL_API_AUTH_TOKEN",   // Index 4
    "fake",
    "REAL_XOR3_KEY_B64",     // Index 6
    "fake",
    "REAL_AES2_KEY_B64",     // Index 8
    "fake",
    "fake"
  ]
}
```

The client must extract the keys from indices **1, 4, 6, and 8**.

---

## Phase 2: Secure Session (Second Request)

Used for sensitive endpoints (e.g., `POST /handshake/secure-echo` or other protected routes). This phase relies on the keys negotiated in Phase 1.

### 1. Request Structure

-   **Header:** `x-auth`: Encrypted using **Layer 1**.
    -   **Decrypted Header:**
        ```json
        {
          "apiAuthToken": "uuid-from-phase-1",
          "timestamp": 1234567890,
          "nonce": "random-string"
        }
        ```
-   **Body:** JSON object `{ "payload": "..." }`
-   **Payload Content:** Encrypted using **Layer 2** (Session Encryption).

### 2. Encryption Algorithm (Layer 2)

This algorithm combines static keys and dynamic session keys for high security.

**Encryption Steps (`encryptSecond`):**
1.  **Serialize:** JSON stringify the object.
2.  **XOR Static 1:** Apply XOR with `HANDSHAKE_XOR1_KEY_B64`.
3.  **AES Static:** Encrypt using **AES-256-ECB** with `HANDSHAKE_AES1_KEY_B64`.
4.  **XOR Static 2:** Apply XOR with `HANDSHAKE_XOR2_KEY_B64`.
5.  **XOR Dynamic:** Apply XOR with `SESSION_XOR3_KEY` (Dynamic).
6.  **AES Dynamic:** Encrypt using **AES-256-CBC** with `SESSION_AES2_KEY` and `SESSION_AES2_IV`.
7.  **Encode:** Return as Base64.

**Decryption Steps (`decryptSecond`):**
1.  **Decode:** Base64 decode to buffer.
2.  **AES Dynamic:** Decrypt using **AES-256-CBC** with `SESSION_AES2_KEY` and `SESSION_AES2_IV`.
3.  **XOR Dynamic:** Apply XOR with `SESSION_XOR3_KEY`.
4.  **XOR Static 2:** Apply XOR with `HANDSHAKE_XOR2_KEY_B64`.
5.  **AES Static:** Decrypt using **AES-256-ECB** with `HANDSHAKE_AES1_KEY_B64`.
6.  **XOR Static 1:** Apply XOR with `HANDSHAKE_XOR1_KEY_B64`.
7.  **Parse:** Convert to string and JSON parse.

### 3. Security Checks (Phase2AuthGuard)

The server performs rigorous checks for every request:

1.  **Header Decryption:** `x-auth` is decrypted using Layer 1.
2.  **Session Lookup:** Finds the session using `apiAuthToken`.
3.  **Session Expiry:** Checks if the session is expired (Default TTL: 24 hours).
4.  **Timestamp Validation:** Request timestamp must be within 5 seconds of server time.
5.  **Replay Protection:**
    -   Tracks `lastNonce` from the header.
    -   Tracks `lastBodyNonce` from the payload (if present).
    -   Rejects requests if nonces are reused.
6.  **Payload Decryption:** Decrypts body using the session-specific keys (`AES2`, `IV`, `XOR3`).

## Code Architecture

-   **`src/modules/handshake/handshake.controller.ts`**: Entry points.
-   **`src/modules/handshake/handshake.service.ts`**: Business logic for handshake and session management.
-   **`src/modules/handshake/handshake-crypto.service.ts`**: Implementation of Layer 1 and Layer 2 encryption/decryption primitives.
-   **`src/modules/handshake/guards/phase2-auth.guard.ts`**: Interceptor guard for Phase 2 validation (header parsing, replay checks).
-   **`src/modules/handshake/interceptors/phase2-encrypt.interceptor.ts`**: (Implied) Handles encrypting the response back to client in Phase 2.
